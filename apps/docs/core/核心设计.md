# 核心设计（`@mixeditor/core`）
MixEditor 的核心设计旨在提供一个灵活、可扩展的编辑器框架，通过定义操作、实体和上下文等核心概念，并结合通用设计模式，支持复杂的内容管理和行为扩展。本文档详细阐述了核心组件的设计理念及其实现方式。
## 1. 设计原则与通用模式
本节介绍 MixEditor 的两大核心设计模式，为后续概念提供理论基础。这些模式确保了系统的模块化、可扩展性和执行顺序的动态管理。
### 1.1 黑盒-行为-处理器模式
定义黑盒对象、行为定义、行为处理器三个概念。通过解耦对象定义与行为实现，支持插件动态扩展功能。
* **黑盒对象**：仅定义类型字段，具体结构由实现者决定，保持灵活性。
* **行为定义**：定义黑盒对象可有的行为，定义如下：
	$$Behavior = (Type, ParamsSchema)$$
* **行为处理器**：实现行为的函数，接受参数并执行具体逻辑。


扩展定义：
$$
\begin{align*}
& CoreBehavior<ExtendParam, ExCtx> \ = \\
& \quad Behavior \ \land \ (Behavior.ParamsSchema \ \land \ ExtendParam \ \land \{ex\_ctx: ExCtx\})
\end{align*}
$$
### 1.2 DAG 动态执行顺序管理
本模式的机制是，管理者通过注册执行器并指定前后驱节点，自动生成执行序列。可以利用有向无环图（DAG）动态编排执行顺序，解决优先级、并发和循环依赖问题。

插件初始化和事件总线（管线管理）使用此模式。DAG 提供的拓扑排序保证了依赖关系的正确执行，避免死锁或顺序错误。
## 2. 实体相关
实体是 MixEditor 的核心内容单元，围绕实体构建了行为、模式和上下文管理体系，形成内容管理的完整框架。
### 2.1 实体（$Ent$）
实体是编辑器中的最小内容单元，为黑盒，仅能通过行为处理器访问。其实际是运行时的动态对象，而状态由类型决定。定义为：  
$$Ent = (ID, Type, State)$$
其中：  
1. **唯一标识（$ID$）**：全域唯一，用于实体追踪。  
2. **类型标识（$Type$）**：满足 $Type \in EntCtx.Schemas.Type$。  
3. **状态（$State$）**：属性集合，符合 $EntCtx.Schemas[Type].StateSchema$ 的格式定义。  
    - **实体关系（可选）**：通过引用其他实体 $ID$ 表达树状、图状或链状关系。  
### 2.2 实体行为（$EntBehavior$）
实体行为描述实体支持的操作，基于黑盒-行为模式，定义为：  
$$EntBehavior \ = \ CoreBehavior<\{target: Ent\}, ExCtx)>$$

类型定义为：
```ts
interface BaseEntBehaviorParams {
  target: Ent;
}
type BuildEntBehaviorParams<T extends object> = BaseEntBehaviorParams & T;
type EntBehaviorHandler<TParams extends object, TResult> = (params: BuildEntBehaviorParams<TParams>) => TResult;
```

核心预设了这些实体行为：
```ts
interface EntBehaviorMap {
  to_tdo: EntBehaviorHandler<{}, TDO>;
}
```
### 2.3 实体模式（$EntSchema$）
实体模式描述实体类型的完整信息。定义为：  
$$EntSchema = (Type, StateSchema, Tags, BehaviorHandlers)$$
- **标签集（$Tags$）**：实体的元信息标签。
### 2.4 实体TDO（$EntTDO$）
实体TDO用于持久化的实体表示。定义为：
$$EntTDO = (ID, Type, State)$$
其中：
- **唯一标识（$ID$）**：全域唯一，用于实体追踪。
- **类型标识（$Type$）**：确定实体语义类别，满足 $Type \in EntCtx.Schemas.Type$。
- **状态（$State$）**：实体属性集合，符合 $EntCtx.Schemas[Type].StateSchema$ 的格式定义。
### 2.5 实体TDO行为（$EntTDOBehavior$）
TDO 的操作行为。定义为：  
$$EntTDOBehavior \ = \ CoreBehavior<\{target: Ent\}, ExCtx)>$$
类型定义为：
```ts
interface BaseEntTDOBehaviorParams {
  target: Ent;
}
type BuildEntTDOBehaviorParams<T extends object> = BaseEntTDOBehaviorParams & T;
type EntTDOBehaviorHandler<TParams extends object, TResult> = (params: BuildEntTDOBehaviorParams<TParams>) => TResult;
```

核心预设了这些实体行为：
```ts
interface EntTDOBehaviorMap {
  to_ent: EntTDOBehaviorHandler<{}, Ent>;
}
```
### 2.6 实体TDO模式（$EntTDOSchema$）
实体TDO模式描述TDO类型的完整信息，定义为：  
$$EntSchema = (Type, StateSchema, BehaviorHandlers)$$
### 2.7 领域上下文表（$DomainCtxMap$）
领域上下文表管理特定领域的临时数据。定义为：
$$
DomainCtx = (Type, Map: \{NodeRef_i: DomainCtx_i\})
$$
### 2.8 实体上下文（$EntCtx$）
实体和 TDO 的全局管理上下文，定义为：  
$$
\begin{align*}
& EntCtx = (\\
& \quad Schemas: \{EntSchema_i\}, \\
& \quad Behaviors: \{EntBehavior_i\}, \\
& \quad DomainCtxMaps: \{ DomainCtxMap_i \} \\
& \quad TDOSchemas: \{EntTDOSchema_i\}, \\
& \quad TDOBehaviors: \{TDOBehavior_i\}, \\
& \quad ExCtx \\
)
\end{align*}
$$
### 2.9 实体数据用途对比
实体、实体TDO、领域上下文都是为了容纳实体的状态，但它们细分上有很大的区别，其区分如下：

| 特性   | 实体（$Ent$） | 实体TDO（$TDO$） | 领域上下文（$DomainCtx$）  |
| ---- | --------- | ------------ | ------------------- |
| 来源   | 实体模式定义    | 实体模式定义       | 领域上下文模式定义           |
| 储存内容 | 运行时主要数据   | 持久化数据        | 领域扩展的临时数据           |
| 目的   | 核心内容管理    | 状态持久化        | 无侵入式扩展与领域数据统一管理<br> |

## 3. 内容相关
### 3.1 根实体（$RootEnt$）
内容树的根节点。定义为：
$$RootEnt = ("root", RootState)$$

## 4. 操作相关
操作管理状态迁移，包含操作定义、执行和历史管理。
### 4.1 操作（$Op$）
操作描述状态迁移 $S \xrightarrow{Op} S'$，定义为二元组：  
$$Op = (Type, Params)$$  
其中：  
1. **类型（$Type$）**：操作语义类别，满足 $Type \in OpCtx.Schemas.Type$。  
2. **参数（$Params$）**：操作参数，满足 $Ctx \in OpCtx.Schemas[Type].Params$。  
### 4.2 逆操作（$Op^{-1}$）  
恢复状态的操作，满足：  
$$S \xrightarrow{Op} S' \xrightarrow{Op^{-1}} S$$
### 4.3 操作合并  
为优化存储，操作可按规则合并：  
1. **扩展合并**：同类型且参数可线性组合时，合并为 $\Delta_{merge} = (Type, f_{merge}(Params_1, Params_2))$。
2. **相消合并**：$Op$ 与 $Op^{-1}$ 合并时相互抵消。 
### 4.4 操作行为（$OpBehavior$）
操作行为是操作的执行逻辑，基于黑盒-行为模式。定义为：
$$OpBehavior<ExCtx> \ = \ CoreBehavior<\{target: Ent\}, ExCtx)>$$

类型定义为：
```ts
interface BaseOpBehaviorParams<ExCtx> {
  target: Op;
  ex_ctx: ExCtx;
}
type BuildOpBehaviorParams<TParams extends object, ExCtx> = BaseOpBehaviorParams<ExCtx> & TParams;
type OpBehaviorHandler<TParams extends object, TResult, ExCtx = {}> = (params: BuildOpBehaviorParams<TParams, ExCtx>) => TResult;
```

核心预设了这些操作行为：
```ts
interface OpBehavior {
  apply: OpBehaviorHandler<{}, void>;
  invert: OpBehaviorHandler<{}, void>;
  merge: OpBehaviorHandler<{
    target2: Op;
  }, Op>;
}
```
### 4.5 操作模式（$OpSchema$）
操作模式是操作类型的参数和行为实现：  
$$OpSchema = (Type, ParamsSchema, BehaviorHandlers)$$
### 4.6 事务（$Transaction$）
事务是一种操作，也是一系列的操作的集合，定义为：
$$Transaction = ("transaction", TransactionCtx)$$
- **事务上下文（$TransactionCtx$）**：事务上下文，包含如下信息：
```ts
interface TransactionCtx {
  ops: Op[];
}
```
### 4.7 操作执行流程
操作需通过操作和实体行为处理器执行：  
1. 根据 $Op.Type$ 匹配 $OpCtx.Behaviors$ 中的处理器。  
2. 调用处理器，按 $Params$ 调用 $EntCtx.Behaviors$ 中的处理器更改实体状态。  
### 4.8 操作上下文（$OpCtx$）
操作模式与行为的全局集合：  
$$
\begin{align*}
& OpCtx<ExCtx> = ( \\
& \quad Schemas: \{OpSchema_i\},\\
& \quad Behaviors: \{OpBehavior<ExCtx>_i\},\\
& \quad ExCtx\\
& )
\end{align*}
$$

## 5. 历史管理相关
### 5.1 历史上下文（$HistoryCtx$）
历史上下文是一个缓冲区，其缓存已经发生过的操作，提供操作记录和撤销的功能。定义如下
$$HistoryCtx = (OpBuffer, RedoBuffer, Config)$$
其中：
* **操作缓冲区（$OpBuffer$）**：记录已经发生的操作。
* **重做缓冲区（$RedoBuffer$）**：记录已撤销，可重做的步骤。
* **配置（$Config$）**：储存历史上下文的配置。

## 6. 管线相关
### 6.1 管线（$Pipe$）
管线是由多阶段处理器构成的有向无环图（DAG），用于编排编辑器核心行为的执行流程。定义为：
$$
\begin{align*}
& Pipe=(\\
& \quad Type,\\
& \quad HandlerDatas: \{ PipeHandlerData_i \},\\
& \quad EventSchema\\
& )
\end{align*}
$$
其中：
- **类型（$Type$）**：管线的类型。
- **处理器数据集（$HandlerDatas$）**：管线的处理器，以及它们的连接信息。

管线执行时，将拓扑排序阶段并按依赖顺序调用处理器。
### 6.2 处理器数据（$PipeHandlerData$）
处理器数据包含处理器，以及它们与锚点的连接信息，处理器会在前驱锚点完成后触发，然后通知后驱锚点自己已执行。

**锚点名称（$AnchorName$）** 是个字符串，会在管线内部产生**锚点（$Anchor$）**，用于支撑 DAG 的结构。

处理器数据定义如下：
$$
\begin{align*}
& PipeHandlerData = (\\
& \quad Handler,\\
& \quad PrevAnchors: \{ AnchorName_i \},\\
& \quad NextAnchors: \{ AnchorName_i \}\\
& )
\end{align*}
$$
其中：
* **处理器**：管线处理器，是个函数。
* **前驱锚点列表（$PrevAnchors$）**：记录需要等待其完成，自己才能执行的锚点名称列表。
* **后驱锚点列表（$NextAnchors$）**：记录自己完成后方可执行的锚点名称列表。
### 6.3 事件（$Event$）
事件是管线执行过程中，向各个管线处理器传递的消息对象。定义为：
$$Event=(Type,Data,EventCtx,ExCtx)$$
其中：
- **类型（$Type$）**：管线的类型。
* **数据（$Data$）**：事件传递的数据。具有只读约束。
* **事件上下文（$EventCtx$）**：用于管线处理器向下级处理器或管线末端传递数据。
### 6.4 事件模板（$EventSchema$）
事件模板定义了事件的类型。定义为：
$$Event=(Type,DataSchema,EventCtxSchema?)$$
- **类型（$Type$）**：管线的类型。
- **数据模板（$DataSchema$）**：事件携带的数据模板。
- **事件上下文（$EventCtxSchema$）（可选）**：事件上下文的模板。
### 6.5 管线总线（$PipeBus$）
管线总线包含多个管线的信息。定义为：
$$PipeBus = \{Name_i: Pipe_i, \ ExCtx\}$$

## 7. 选区相关
### 7.1 选区（$Selection$）
选区用于标识选中实体或实体范围的抽象概念。定义为：
$$Selection=(Type,Data)$$
其中：
- **类型（$Type$）**：选区的类型。
* **数据（$Data$）**：选区的数据。记录选择的实体或实体范围。
### 7.2 选区模板（$SelectionSchema$）
选区模板定义了选区的类型。定义为：
$$SelectionSchema=(Type, \ DataSchema)$$
- **类型（$Type$）**：选区的类型。
- **数据模板（$DataSchema$）**：选区的数据模板。
### 7.3 选区上下文（$SelectionCtx$）
记录选区的信息，定义为：
$$SelectionCtx=(CurrSelection: Selection, \ SelectionSchemas: \{ SelectionSchema_i \})$$

## 8. 序列化相关
### 8.1 序列化器（$TDOSerializer$）
序列化器将TDO转换为某个结构的数据。定义：
$$TDOSerializer = (Type, Handler, ConfigSchema, Result, TaskCtx)$$
其中：
* **处理器（$Handler$）**：定义为 $$\begin{align*}
& (params: \{ \\
& \quad input: TDO, \\
& \quad config: ConfigSchema, \\
& \quad ex\_ctx: ExCtx, \\
& \quad task\_ctx: TaskCtx \\
& \}) => Result
\end{align*}$$
* **配置模式（$ConfigSchema$）**：配置的类型。
* **结果（$Result$）**：序列化器的返回结果。
### 8.2 反序列化器（$TDODeserializer$）
反序列化器将某个结构的数据转换TDO。定义：
$$TDODeserializer = (Type, \ Handler, \ ConfigSchema, \ Input, \ TaskCtx)$$
其中：
* **处理器（$Handler$）**：定义为 $$\begin{align*}
& (params: \{ \\
& \quad input: Input, \\
& \quad config: ConfigSchema, \\
& \quad ex\_ctx: ExCtx, \\
& \quad task\_ctx: TaskCtx \\
& \}) => TDO
\end{align*}$$
* **配置模式（$ConfigSchema$）**：配置的类型。
* **输入（$Input$）**：反序列化器需要的输入。
### 8.3 TDO序列化上下文（$TDOSerializeCtx$）
管理TDO的序列化器和反序列化器。定义为：
$$TDOConvertCtx=(Serializers: \{Serializer_i\}, \ Deserializers: \{Deserializer_i\}, \ ExCtx)$$

## 9. 插件相关
### 9.1 插件（$Plugin$）
插件用于扩展编辑器的功能。定义为：
$$
\begin{align*}
& Plugin = (\\
& \quad ID, \\
& \quad PluginMeta,\\
& \quad LifeCycleHandlerMap,\\
& \quad Exposed,\\
& )
\end{align*}
$$
### 9.2 插件元信息（$PluginMeta$）
$$
\begin{align*}
& PluginMeta = \{\\
& \quad version: SemverVersion,\\
& \quad dependencies: string[],\\
& \quad authors: string[],\\
& \}
\end{align*}
$$

### 9.3 插件生命周期钩子表（$LifeCycleHandlerMap$）
$$
\begin{align*}
& LifeCycleHandlerMap = (\\
& \quad InitHandler, \\
& \quad DisposeHandler, \\
& )
\end{align*}
$$
其中：
* **初始化处理器（$InitHandler$）**：$(ctx: CoreCtx)=>Exposed;$
* **销毁处理器（$DisposeHandler$）**：$(ctx: CoreCtx)=>void;$
### 9.4 插件上下文（$PluginCtx$）
插件上下文管理插件的注册、生命周期和依赖关系。定义为：
$$
\begin{align*}
& PluginCtx = (\\
& \quad Plugins: \{ Plugin_i \},\\
& \quad PluginsExposeds: \{ PluginsExposed_i \},\\
& \quad ExCtx,\\
& )
\end{align*}
$$

## 10. 核心上下文（$CoreCtx$）
核心上下文整合所有上下文，形成编辑器核心，定义为： 
$$\begin{align*}
& CoreCtx = ( \\
& \quad EntCtx, \ RootEnt, \ OpCtx, \\
& \quad HistoryCtx, \ PipeCtx, \ SelectionCtx, \\
& \quad TDOSerializeCtx, \ PluginCtx\\
& )
\end{align*}$$